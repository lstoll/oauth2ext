name: Go
on: [push]
jobs:

  build:
    name: "Build (Go ${{ matrix.go }} darwin) - ${{ matrix.envs.CGO_ENABLED == '1' && 'CGO' || 'Pure Go' }}"
    runs-on: macos-latest
    strategy:
      # we use a matrix because the two test types don't interact well -
      # keychain permissions will pop up a dialog to allow access, and we can't
      # approve that.
      matrix:
        envs:
        - CGO_ENABLED: 0
        - CGO_ENABLED: 1
        go: [stable] # go: [ stable, oldstable ]
    env:
      GOTOOLCHAIN: local

    steps:

    - name: Print CGO_ENABLED
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
      run: echo "CGO_ENABLED is $CGO_ENABLED"

    - name: Check out code into the Go module directory
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: stable
      id: go

    - name: Get dependencies
      run: |
        go mod download
        cd tpmsecrets && go mod download && cd -
        cd keychainsecrets && go mod download && cd -

    - name: Build & Test (oauth2ext)
      run: |
        go build ./...
        go test ./...
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
        TEST_KEYCHAIN: 1
        TEST_CTK_IDENTITY: 1

    - name: Build & Test (tpmsecrets)
      working-directory: ./tpmsecrets
      run: |
        go build ./...
        go test ./...
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}

    - name: Build & Test (keychainsecrets)
      working-directory: ./keychainsecrets
      run: |
        go build ./...
        go test ./...
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
        TEST_KEYCHAIN: 1
        TEST_CTK_IDENTITY: 1


    # The goal here is to test against the keychain. We expect the same binary
    # to be able to read existing data in repeated invocations, and a new binary
    # to not be able to, but also clean up without user interaction and store
    # new values. We also test the CLI version where it makes sense, it's items
    # don't conflict with the direct keychain versions.

    - name: Build CLI Token test binary
      working-directory: ./keychainsecrets
      run: go test -c .
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}

    - name: Test CLI Token initial
      working-directory: ./keychainsecrets
      run: ./keychainsecrets.test -test.v -test.timeout=15s
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
        TEST_KEYCHAIN: 1
        TEST_KEYCHAIN_CREDENTIAL_CACHE: 1
        TEST_KEYCHAIN_CLI_CREDENTIAL_CACHE: 1

    - name: Test CLI Token with existing entry
      working-directory: ./keychainsecrets
      run: ./keychainsecrets.test -test.v -test.timeout=15s
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
        TEST_KEYCHAIN: 1
        TEST_KEYCHAIN_CREDENTIAL_CACHE_EXISTING: 1
        TEST_KEYCHAIN_CREDENTIAL_CACHE: 1

    # just re-compiling the same input results in a binary that's "close enough"
    # for the keychain. So inject a new file to change this, and also indicate
    # the change.
    - name: Build modified CLI Token test binary
      working-directory: ./keychainsecrets
      run: |
        cat <<- EOF > modify.go
        package keychainsecrets

        import "log"

        func init() {
          log.Printf("this is a modified binary")
        }
        EOF

        go test -c .
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}

    - name: Re-test CLI token with modified binary
      working-directory: ./keychainsecrets
      run: ./keychainsecrets.test -test.v -test.timeout=15s
      env:
        CGO_ENABLED: ${{ matrix.envs.CGO_ENABLED }}
        TEST_KEYCHAIN_CREDENTIAL_CACHE: 1
        TEST_KEYCHAIN_CLI_CREDENTIAL_CACHE: 1
